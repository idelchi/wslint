package main

import (
	"flag"
	"io"
	"log"
	"os"
	"runtime"
	"strings"
)

//nolint:gochecknoglobals // Global variable for CI stamping.
var versionStamp = "unknown - unofficial & generated by unknown"

func usage() {
	log.Println("wslint checks or fixes files with trailing whitespaces and enforces final newlines")
	log.Println("Usage: wslint [flags] [path ...]")
	flag.PrintDefaults()
}

// exit prints the message and exits with the specified exit code.
func exit(code int, msg string) {
	log.Println(msg)

	if code != 0 {
		usage()
	}

	os.Exit(code)
}

//nolint:funlen // This function is long, but it's not complex.
func main() {
	// Flags for the CLI
	var (
		fix      = flag.Bool("w", false, "format file in-place")
		verbose  = flag.Bool("d", false, "debug output")
		exclude  = flag.String("e", "", "exclude pattern, comma separated")
		hidden   = flag.Bool("a", false, "show hidden files & folders")
		parallel = flag.Int("j", runtime.NumCPU(), "number of parallel jobs, defaults to number of CPUs")
		version  = flag.Bool("v", false, "print version")
		quiet    = flag.Bool("q", false, "suppress messages")
	)

	// No time stamp in the log output
	log.SetFlags(0)

	// Set the usage message & parse the flags
	flag.Usage = usage
	flag.Parse()

	switch {
	// If the version flag is set, print the version and exit
	case *version:
		exit(0, versionStamp)
	// If no arguments are given, raise an error message
	case flag.NArg() == 0:
		exit(1, "Error: Need to provide at least one path element")
	// If the number of parallel jobs is less than 1, raise an error message
	case *parallel <= 0:
		exit(1, "Error: Number of parallel jobs must be greater than 0")
	}

	// Create a logger for debug messages
	verboseLog := log.New(os.Stdout, "", 0)
	if !*verbose {
		// Disable debug messages if the verbose flag is not set,
		verboseLog.SetOutput(io.Discard)
	}

	// Disable the logger if the quiet flag is set
	if *quiet {
		log.SetOutput(io.Discard)
		verboseLog.SetOutput(io.Discard)
	}

	// Split the exclude patterns into a slice
	excludes := strings.Split(*exclude, ",")

	for i, exclude := range excludes {
		// Remove any leading and trailing whitespace
		exclude = strings.TrimSpace(exclude)
		// Remove "./" from the beginning of the pattern, if it exists
		exclude = strings.TrimPrefix(exclude, "./")
		excludes[i] = exclude
	}

	// Create the options
	options := Options{
		Exclude:         excludes,
		NumberOfWorkers: *parallel,
		Fix:             *fix,
		Logger:          verboseLog,
		Patterns:        flag.Args(),
		Hidden:          *hidden,
	}

	os.Exit(match(options))
}
