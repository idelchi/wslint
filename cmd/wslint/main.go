package main

import (
	"flag"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/fatih/color"
	"github.com/idelchi/wslint/internal/checkers"
	"github.com/idelchi/wslint/internal/linter"
)

//nolint:gochecknoglobals // Global variable for CI stamping.
var versionStamp = "unknown - unofficial & generated by unknown"

func usage() {
	log.Println("wslint checks or fixes files with trailing whitespaces and enforces final newlines")
	log.Println("Usage: wslint [flags] [path ...]")
	flag.PrintDefaults()
}

// exit prints the message and exits with the specified exit code.
func exit(code int, msg string) {
	log.Println(msg)

	if code != 0 {
		usage()
	}

	os.Exit(code)
}

func main() {
	// Create the Wslint instance
	wslint := Wslint{}

	wslint.Parse()

	// Configure the checkers
	wslint.checkers = []linter.Checker{
		&checkers.Whitespace{},
		&checkers.Blanks{},
	}

	if wslint.options.Exp {
		wslint.checkers = append(wslint.checkers, &checkers.Stutters{})
		if wslint.options.Fix {
			log.Println(color.YellowString("Fixing stutters is an experimental feature and may not work as expected"))
			log.Println(color.YellowString("Press [enter] to continue or [ctrl+c] to abort"))

			sigCh := make(chan os.Signal, 1)
			enterCh := make(chan struct{})

			// Register to receive SIGINT (Ctrl+C) signals
			signal.Notify(sigCh, syscall.SIGINT)

			// Goroutine to detect the Enter key
			go func() {
				_, _ = os.Stdin.Read([]byte{0})
				enterCh <- struct{}{}
			}()

			select {
			case <-sigCh:
				log.Println("Ctrl+C was pressed. Aborting...")
				os.Exit(0)
			case <-enterCh:
				log.Println("Enter was pressed. Continuing...")
			}
		}
	}

	if wslint.Match(); len(wslint.files) == 0 {
		os.Exit(1)
	}

	os.Exit(wslint.Process())
}
